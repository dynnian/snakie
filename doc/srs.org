#+title: Descripción del juego Snake
#+author: Clay Gomera
#+description: Requerimientos de sistema del juego Snake

* Requerimientos base
** Descripción del juego
El juego de la Serpiente es un sencillo juego arcade en 2D donde el jugador
controla una serpiente que se mueve por una cuadrícula. El objetivo es comer
objetos de comida colocados al azar en la cuadrícula y crecer en longitud. El
juego finaliza si la serpiente choca consigo misma o con los límites de la
cuadrícula.

** Componentes del juego
- *Cuadrícula:* Una cuadrícula cuadrada que representa el área de juego, dividida
  en celdas.

- *Serpiente:* Una serie de segmentos conectados que se mueven alrededor de la
  cuadrícula.

- *Comida:* Objetos comestibles colocados al azar en la cuadrícula para que la
  serpiente los consuma.

- *Puntuación:* Lleva un registro de la puntuación del jugador, generalmente
  basada en el número de objetos de comida consumidos.

** Mecánicas del juego
- *Movimiento de la serpiente:* La serpiente se mueve continuamente en una
  dirección específica (arriba, abajo, izquierda o derecha). El jugador puede
  cambiar la dirección de la serpiente utilizando controles de entrada (por
  ejemplo, las teclas de flecha).

- *Comer comida:* Cuando la cabeza de la serpiente ocupa la misma celda que un
  objeto de comida, lo consume y su longitud aumenta en un segmento. Aparece un
  nuevo objeto de comida en una ubicación aleatoria de la cuadrícula.

- *Colisiones:* Si la cabeza de la serpiente choca con su propio cuerpo o con
  los límites de la cuadrícula, el juego finaliza.

- *Crecimiento y velocidad:* A medida que la serpiente crece más larga, el juego
  puede aumentar la dificultad acelerando el movimiento de la serpiente.

** Implementación del juego
- *Representación de la cuadrícula:* El juego se puede implementar utilizando
  una matriz en 2D para representar la cuadrícula. Cada celda de la cuadrícula
  puede estar vacía, ocupada por la serpiente o contener comida.

- *Movimientos de la serpiente:* El movimiento de la serpiente se puede
  implementar utilizando una estructura de datos de lista enlazada. Cada
  segmento de la serpiente se representa como un nodo que contiene su posición
  en la cuadrícula y una referencia al siguiente segmento.

- *Entrada del usuario:* El juego debe manejar la entrada del usuario para
  cambiar la dirección de la serpiente. Esto se puede hacer capturando eventos
  del teclado y actualizando el movimiento de la serpiente en consecuencia.

- *Bucle del juego:* El juego se ejecuta en un bucle, donde actualiza
  continuamente la posición de la serpiente y verifica las colisiones y el
  consumo de comida. Además, vuelve a dibujar la cuadrícula para mostrar el
  estado actualizado del juego.

- *Detección de colisiones:* Se utilizan algoritmos de detección de colisiones
  para determinar si la cabeza de la serpiente choca con los segmentos de su
  cuerpo o con los límites de la cuadrícula.

- *Seguimiento de puntuación:* El juego lleva un registro de la puntuación del
  jugador contando el número de objetos de comida consumidos.

** Gráficos e interfaz de usuario
El juego se puede implementar con gráficos simples utilizando caracteres ASCII o
elementos gráficos más complejos utilizando una biblioteca o framework de
gráficos. La interfaz de usuario puede incluir una pantalla de puntuación, una
pantalla de fin de juego y opciones de menú para iniciar/reiniciar el juego. Los
efectos de sonido y la música de fondo pueden mejorar la experiencia de juego,
pero no son esenciales para la funcionalidad básica.

* Descripción orientada a objetos
** Identificar las entidades
Determinar las diferentes entidades u objetos dentro del juego. Para un juego de
la Serpiente, podemos identificar entidades como Serpiente, Comida, Tablero de
Juego y Puntuación.

** Definir Clases
Crear una clase para cada entidad identificada en el paso anterior. Cada clase
tendrá atributos (datos) y métodos (comportamiento) asociados. Por ejemplo:

- La clase Serpiente puede tener atributos como los segmentos de su cuerpo
  (representados como nodos de lista enlazada), dirección, longitud, y métodos
  como mover(), cambiarDirección(), crecer().

- La clase Comida puede tener atributos como posición, tipo, y métodos como
  generar(), verificarColisión().

- La clase Tablero de Juego puede tener atributos como ancho, altura, y métodos
  como dibujar(), verificarColisiónConPared().

- La clase Puntuación puede tener atributos como puntuación actual, puntuación
  más alta, y métodos como aumentar(), reiniciar().

** Establecer Relaciones entre Clases
Determinar las relaciones entre las clases. Por ejemplo:

- La clase Serpiente interactúa con la clase Comida a través de métodos como
  comerComida().

- La clase Tablero de Juego contiene instancias de las clases Serpiente y
  Comida.

- La clase Puntuación puede ser actualizada por la clase Serpiente cada vez que
  come comida.

** Encapsular Datos
Definir atributos privados y métodos públicos para cada clase. Los atributos
privados solo pueden ser accedidos o modificados desde dentro de la clase,
mientras que los métodos públicos permiten que el código externo interactúe con
los objetos de la clase.

** Implementar Métodos de Clase
Escribir los detalles de implementación para cada método de clase. Estos métodos
definen cómo se comportan los objetos. Por ejemplo, el método mover() en la
clase Serpiente podría actualizar la posición de la serpiente según su dirección
actual.

** Crear Instancias de Objetos
Crear objetos a partir de las clases definidas para representar instancias
específicas dentro del juego. Por ejemplo:

- Crear un objeto Serpiente para representar la serpiente controlada por el
  jugador.

- Crear un objeto Comida para representar la comida que la serpiente necesita
  comer.

- Crear un objeto Tablero de Juego para representar el área de juego.

- Crear un objeto Puntuación para llevar un registro de la puntuación del
  jugador.

** Implementar Lógica del Juego
Utilizar los objetos creados para implementar la lógica general del juego, como
actualizar el estado del juego, manejar colisiones y procesar la entrada del
usuario.

** Manejar Interacciones
Definir cómo interactúan los objetos entre sí. Esto puede incluir acciones como
la serpiente comiendo comida, verificar colisiones con los límites del tablero
de juego o consigo misma, y actualizar la puntuación.

** Implementar el Bucle del Juego
Crear un bucle que actualice continuamente el estado del juego, renderice los
gráficos, maneje la entrada del usuario y verifique las condiciones de fin de
juego (por ejemplo, colisión con la pared o consigo misma).

** Probar y Depurar
Probar a fondo el juego ejecutando diferentes escenarios, verificando que las
interacciones entre objetos funcionen correctamente y depurando cualquier
problema que surja.
